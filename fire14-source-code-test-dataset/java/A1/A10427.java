package MyAllgoritmicLib;

import java.util.ArrayList;

public class Dejkstra {
	// ---------------------------------------------------------------------------
	// Алгоритм Дейкстры.поиска кратчайшего пути

		int v;
	
	   int infinity=Integer.MAX_VALUE;                     // Бесконечность
	   int p= 6;				// Количество вершин в графе
	   int a[][]={ {0,1,0,0,1,3},  // Матрица смежности графа
	   {  1,0,5,0,0,1},
	   {            0,5,0,5,20,1},
	   {   0,0,5,0,3,2},
	   {           1,0,20,3,0,10},
	   {  3,1,1,2,10,0  }};

	   // Будем искать путь из вершины s в вершину g
	   public ArrayList<Integer> search(int s, int g){
		   ArrayList<Integer> result = new ArrayList<Integer>();
	   int x[] = new int[p]; // Массив, содержащий единицы и нули для каждой вершины,
	                  // x[i]=0 - еще не найден кратчайший путь в i-ю вершину,
	                  // x[i]=1 - кратчайший путь в i-ю вершину уже найден
	   int t[] = new int[p];  // t[i] - длина кратчайшего пути от вершины s в i
	   int h[] = new int[p];  // h[i] - вершина, предшествующая i-й вершине
	   		         // на кратчайшем пути

	   // Инициализируем начальные значения массивов
	   int u;		    // Счетчик вершин
	   for (u=0;u<p;u++)
	   {
	      t[u]=infinity; // Сначала все кратчайшие пути из s в i
		// равны бесконечности
	      x[u]=0;        // и нет кратчайшего пути ни для одной вершины
	   }
	   h[s]=0; // s - начало пути, поэтому этой вершине ничего не предшествует
	   t[s]=0; // Кратчайший путь из s в s равен 0
	   x[s]=1; // Для вершины s найден кратчайший путь
	   v=s;    // Делаем s текущей вершиной
	   
	   while(true)
	   {
	      // Перебираем все вершины, смежные v, и ищем для них кратчайший путь
	      for(u=0;u<p;u++)
	      {
	         if(a[v][u]==0)continue; // Вершины u и v несмежные
	         if(x[u]==0 && t[u]>t[v]+a[v][u]) // Если для вершины u еще не
		// найден кратчайший путь
	            	// и новый путь в u короче чем
		// старый, то
	         {
	            t[u]=t[v]+a[v][u];	// запоминаем более короткую длину пути в
		// массив t и
	            h[u]=v;	// запоминаем, что v->u часть кратчайшего
		// пути из s->u
	         }
	      }

	      // Ищем из всех длин некратчайших путей самый короткий
	      int w=infinity;  // Для поиска самого короткого пути
	      v=-1;            // В конце поиска v - вершина, в которую будет
	                       // найден новый кратчайший путь. Она станет
	                       // текущей вершиной
	      for(u=0;u<p;u++) // Перебираем все вершины.
	      {
	         if(x[u]==0 && t[u]<w) // Если для вершины не найден кратчайший
	                               // путь и если длина пути в вершину u меньше
	                               // уже найденной, то
	         {
	            v=u; // текущей вершиной становится u-я вершина
	            w=t[u];
	         }
	      }
	      if(v==-1)
	      {
	         return null;
	      }
	      if(v==g) // Найден кратчайший путь,
	      {        // выводим его
	         System.out.println("Кратчайший путь из вершины "+s+" в вершину "+g+":");
	   	   u=g;
	   	   while(u!=s)
	         {
	   		   result.add(u);
	            System.out.println(" "+u);
	            u=h[u];
	         }
	         System.out.println(" "+s+". Длина пути - "+t[g]);
	         result.add(s);
	         return result;
	      }
	      x[v]=1;
	   }
	   
	}
	/*
	 * Программа запрашивает вершины s и q и выводит кратчайший путь. Например,
	 * после ввода s = 3, q = 6, программа выводит
	 * 
	 * Нет пути из вершины 3 в вершину 6.
	 * 
	 * После ввода s = 0, q = 2 программа выводит
	 * 
	 * Кратчайший путь из вершины 0 в вершину 2: 2 5 1 0. Длина пути = 3.
	 */

	// ---------------------------------------------------------------------------
	 
	   public static void main(String[] args) {
		   Dejkstra dejkstra = new Dejkstra();
		   ArrayList<Integer> result = dejkstra.search(3, 6);
		   result = dejkstra.search(0, 2);
		   result = null;
		   System.out.println(result);
	   }
    
    }
